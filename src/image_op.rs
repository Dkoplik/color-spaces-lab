/// Первый вариант преобразования rbg в оттенки серого.
/// r - красная составляющая;
/// g - зелёная составляющая;
/// b - синяя составляющая;
/// 
/// Результат тоже в rgb формате, но должнен уже представлять собой оттенок серого.
fn rgb_to_grayscale1(r: u8, g: u8, b: u8) -> (u8, u8, u8) {
    // TODO
    return (0, 0, 0);
}

/// Второй вариант преобразования rbg в оттенки серого.
/// r - красная составляющая;
/// g - зелёная составляющая;
/// b - синяя составляющая;
/// 
/// Результат тоже в rgb формате, но должнен уже представлять собой оттенок серого.
fn rgb_to_grayscale2(r: u8, g: u8, b: u8) -> (u8, u8, u8) {
    // TODO
    return (0, 0, 0);
}

/// Первый вариант преобразования изображения в оттенки серого.
/// buf - тупо вектор с цифрами от 0 до 255, соответственно, каждая тройка чисел это один пиксель.
/// 
/// Результат должен быть записан в сам же buf.
pub fn rgb_buffer_to_grayscale1(buf: &mut Vec<u8>) {
    // TODO
}

/// Второй вариант преобразования изображения в оттенки серого.
/// buf - тупо вектор с цифрами от 0 до 255, соответственно, каждая тройка чисел это один пиксель.
/// 
/// Результат должен быть записан в сам же buf.
pub fn rgb_buffer_to_grayscale2(buf: &mut Vec<u8>) {
    // TODO
}

/// Извлечь из изображения только красный цвет.
/// buf - тупо вектор с цифрами от 0 до 255, соответственно, каждая тройка чисел это один пиксель. 
/// 
/// Результат должен быть записан в сам же buf.
pub fn rgb_buffer_to_red_channel(buf: &mut Vec<u8>) {
    // TODO
}

/// Извлечь из изображения только зелёный цвет.
/// buf - тупо вектор с цифрами от 0 до 255, соответственно, каждая тройка чисел это один пиксель. 
/// 
/// Результат должен быть записан в сам же buf.
pub fn rgb_buffer_to_green_channel(buf: &mut Vec<u8>) {
    // TODO
}

/// Извлечь из изображения только синий цвет.
/// buf - тупо вектор с цифрами от 0 до 255, соответственно, каждая тройка чисел это один пиксель. 
/// 
/// Результат должен быть записан в сам же buf.
pub fn rgb_buffer_to_blue_channel(buf: &mut Vec<u8>) {
    // TODO
}

/// Преобразование представления цвета из RGB в HSV.
/// r - красная составляющая [0, 255];
/// g - зелёная составляющая [0, 255];
/// b - синяя составляющая [0, 255];
/// 
/// На выходе должен быть HSV: H [0, 360], S [0, 100], V [0, 100].
fn rgb_to_hsv(r: u8, g: u8, b: u8) -> (u16, u8, u8) {
    // TODO
    return (0, 0, 0);
}

/// Преобразование представления цвета из HSV в RGB.
/// h - hue [0, 360];
/// s - saturation [0, 100];
/// v - value (brightness) [0, 100];
/// 
/// На выходе должен быть RGB со значениями от 0 до 255.
fn hsv_to_rgb(h: u16, s: u8, v: u8) -> (u8, u8, u8) {
    // TODO
    return (0, 0, 0);
}

/// Прибавляет ко всей картинке buf указанное значение HSV.
/// buf - тупо вектор с цифрами от 0 до 255, соответственно, каждая тройка чисел это один пиксель.
/// h - hue [0, 360];
/// s - saturation [0, 100];
/// v - value (brightness) [0, 100];
/// 
/// Результат должен быть записан в сам же buf в rgb формате.
pub fn add_hsv_to_buffer(buf: &mut Vec<u8>, h: u16, s: u8, v: u8) {
    // TODO из буфера можно брать по одному пикселю, приводить к hsv, суммировать, возвращать обратно в rgb.
}